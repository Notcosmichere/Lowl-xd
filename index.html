<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Glowing Particle Morph & Reset</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; font-family: 'Segoe UI', sans-serif; }
        #ui {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 10px; background: rgba(255, 255, 255, 0.05);
            padding: 12px 20px; border-radius: 50px; backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.1); z-index: 10;
        }
        input {
            background: transparent; border: none; color: white; padding: 8px;
            outline: none; font-size: 16px; width: 180px;
        }
        button {
            background: rgba(255, 255, 255, 0.1); color: white;
            border: 1px solid rgba(255, 255, 255, 0.2); padding: 10px 20px; border-radius: 25px;
            cursor: pointer; font-weight: bold; transition: 0.3s;
        }
        button#morphBtn { background: linear-gradient(45deg, #8e44ad, #bc6ff1); border: none; }
        button:hover { transform: scale(1.05); background: rgba(255, 255, 255, 0.2); }
        button#morphBtn:hover { filter: brightness(1.2); }
    </style>
</head>
<body>

<div id="ui">
    <input type="text" id="textInput" placeholder="Type here..." value="WSUPXDD">
    <button id="morphBtn">MORPH</button>
    <button id="sphereBtn">SPHERE</button>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>
<script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
<script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
<script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
<script src="https://unpkg.com/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
<script src="https://unpkg.com/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
<script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>

<script>
    let scene, camera, renderer, particles, geometry, composer;
    let isRotating = true; 
    const particleCount = 20000;
    
    // We store the original sphere coordinates here to use them later
    const sphereData = []; 

    init();
    animate();

    function init() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 250;

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        const renderScene = new THREE.RenderPass(scene, camera);
        const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        composer = new THREE.EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        const initialPositions = new Float32Array(particleCount * 3);
        for (let i = 0; i < particleCount; i++) {
            const i3 = i * 3;
            const r = 90;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            
            const x = r * Math.sin(phi) * Math.cos(theta);
            const y = r * Math.sin(phi) * Math.sin(theta);
            const z = r * Math.cos(phi);

            initialPositions[i3] = x;
            initialPositions[i3 + 1] = y;
            initialPositions[i3 + 2] = z;

            // Save for reset
            sphereData.push({ x, y, z });
        }

        geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.BufferAttribute(initialPositions, 3));

        const material = new THREE.PointsMaterial({
            color: 0xbc6ff1,
            size: 0.8,
            blending: THREE.AdditiveBlending,
            transparent: true
        });

        particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // --- BUTTON EVENTS ---
        document.getElementById('morphBtn').addEventListener('click', () => {
            isRotating = false;
            gsap.to(particles.rotation, { y: 0, duration: 1 });
            morphToText(document.getElementById('textInput').value);
        });

        document.getElementById('sphereBtn').addEventListener('click', () => {
            backToSphere();
        });
    }

    function morphToText(text) {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 1000; canvas.height = 300;
        ctx.fillStyle = 'white';
        ctx.font = 'bold 120px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(text.toUpperCase(), 500, 150);

        const data = ctx.getImageData(0, 0, 1000, 300).data;
        const points = [];
        for (let y = 0; y < 300; y += 2) {
            for (let x = 0; x < 1000; x += 2) {
                if (data[(y * 1000 + x) * 4] > 128) {
                    points.push({ x: (x - 500) * 0.6, y: (150 - y) * 0.6 });
                }
            }
        }

        const pos = geometry.attributes.position.array;
        for (let i = 0; i < particleCount; i++) {
            const i3 = i * 3;
            const target = points[i % points.length];
            gsap.to(pos, {
                duration: 2,
                ease: "power3.inOut",
                [i3]: target.x,
                [i3 + 1]: target.y,
                [i3 + 2]: (Math.random() - 0.5) * 10,
                onUpdate: () => geometry.attributes.position.needsUpdate = true
            });
        }
    }

    function backToSphere() {
        const pos = geometry.attributes.position.array;
        for (let i = 0; i < particleCount; i++) {
            const i3 = i * 3;
            const target = sphereData[i];

            gsap.to(pos, {
                duration: 2,
                ease: "expo.inOut",
                [i3]: target.x,
                [i3 + 1]: target.y,
                [i3 + 2]: target.z,
                onUpdate: () => {
                    geometry.attributes.position.needsUpdate = true;
                },
                onComplete: () => {
                    isRotating = true; // Start rotating again once finished
                }
            });
        }
    }

    function animate() {
        requestAnimationFrame(animate);
        if (isRotating) particles.rotation.y += 0.003;
        composer.render();
    }
</script>
</body>
</html>
